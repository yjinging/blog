#### NoSQL for Mere Mortals应该是给凡人写的NoSQL书。mere是“仅仅”，mortals是“凡人、人类”。

#### 名词表：
数据：大数据、流数据（streaming data）、高速数据（high-velocity data）
数据存储：数据库（database）、数据存储（data store）、数据仓库（data warehouse）、数据湖泊（data lake）、数据沼泽（data swamp）



##数据库演化过程

* 平面文件数据管理系统（例如磁带）
  
  局限：
1. 数据的存取方式如果和数据在文件中的排列方式不同，那么存取效率就比较低。（例如以ID来排列，却以文件名来获取）
2. 文件结构发生变化之后，相应的程序也需要修改。
3. 不同类型的数据需要有不同的安全保护措施。
4. 同一条数据可能会存储在多份文件之中， 保持一致很麻烦。


* 分层数据模型系统
  
  解决了平面文件管理系统搜索效率不高的问题。树形结构，与多个父节点关联的子节点在各个父节点下分别拷贝一份。
  缺点：
1. 有重复数据，导致的问题和平面文件数据管理系统局限的第4条一样
2. 重复存储导致统计容易出错

* 网络数据管理系统
  
  有向无环图。能够与某节点相连接的节点种类定义在纲要里。缺点：
1. 搜寻时要遍历大量的链接
2. 修改数据库结构后，要更新相应的程序

* 关系型数据库

  在以下几个方面的支持不够：
1. 对大批量读写操作的处理能力
2. 较低的延迟时间和较短的响应时间
3. 较高的数据可用性
  
  改进办法：
  1. 升级设备
  2. 重新设计数据库纲要
  3. 把关系型数据库放在多台服务器中运行（复杂）

  催生NoSQL的动因：
  1. 可伸缩性
  2. 成本开销
  3. 灵活性（有的NoSQL不需要固定的表格结构）
  4. 可用性
  
 
##NoSQL数据库

非关系型数据库类型：键值数据库、文档数据库、列族数据库、图数据库等

####NoSQL数据库四大门类各自的侧重点：
#####轻量级
#####搜索
#####海量
#####数据之间联系

* 一致性：查询时从集群中各台服务器获得相同的结果的性质。与响应时间负相关。可用最低响应数（quorum）来调节。
* 持久性：能够长期维持数据副本正确无误的性质。与响应时间负相关。可用写入阈值（write threshold）来调节。

quorum：读到quorum个一样的结果才认为读的是正确的。
write threshold：写到write threshold个服务器上才认为写操作完成。

##列族数据库
为找到应对VLDB（超大型数据库，Very Large Database）的解决方案,Google发表了BigTable.BigTable成了实现超大规模NoSQL数据库的样板.其他的列族数据库有Cassandra、HBase和Accumulo等。

实现数据库之前必须先把列族定义好，但可以在某个列族内部动态地定义列。

数据值是根据行标识符、列名及时间戳来定位的。

列族能够把其中的各列保存在持久化存储区中的相近位置上。

BigTable同一行内的读取和写入行为都是原子操作

在列族数据库中，用行键（row key）来标识行。行键即关系型数据库中的主键。

列族数据库不支持类型固定的列。

使用列族数据库时，应该很少需要用到连接及子查询。

HDFS：NameNode：管理文件系统，并提供中心化的元数据管理功能。DataNode：存储实际数据。

Cassandra：由对等节点组成。１、采用Gossip协议来传播各服务器状态（即把知道的其他服务器的状态也发出去）２、采用反熵算法来修正副本之间不一致的现象（如果两份数据不匹配，把旧的替换掉）３、待写入节点遇故障时，启动提示移交机制，等故障恢复后，再由代理节点把写信息移交。

列族数据库的基本组件：１、键空间：顶级数据结构。类似于关系型数据库的纲要（schema，模式）。２、行键：可以用来对数据进行分区和排序。３、列：包括列名、时间戳或其他形式的版本戳、列值。４、列族：向列族数据库中添加新列只需在客户端程序中给出列名。

提交日志：如果等数据写入磁盘再发送写应答，则需要等磁盘的读写头移到正确的位置（上一次写完的位置），故把写操作记录到提交日志里面，更快速。

Bloom filter（布隆过滤器）：用来判断某个元素是否是某个集合的成员。可能会出现假阳性错误（把本来不在集合中的元素误判为在），但不会出现元素在集合里判断不在的情况。所占的内存比一般的哈希函数要少。
























